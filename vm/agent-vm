#!/bin/bash

set -e -o pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

function stop_vm {
  local vm_name="$1"

  if ! vm_domain_exists "$vm_name"; then
    echo "Error: VM does not exist: $vm_name" >&2
    exit 1
  fi

  if ! vm_is_running "$vm_name"; then
    echo "VM is already stopped: $vm_name"
    exit 0
  fi

  echo "Stopping VM: $vm_name"
  virsh shutdown "$vm_name"
  echo "VM stopped (graceful shutdown initiated)."
}

function destroy_vm {
  local vm_name="$1"
  local workspace_name="$2"

  echo "Destroying VM: $vm_name"

  # Extract branch name from VM name (format: repo-branch)
  local branch_name="${vm_name#*-}"

  # Unmount SSHFS if mounted
  unmount_vm_workspace

  # Stop and destroy domain if exists
  if vm_domain_exists "$vm_name"; then
    virsh destroy "$vm_name" 2>/dev/null || true
    virsh undefine "$vm_name" 2>/dev/null || true
  fi

  # Switch to workspace and destroy Terraform resources
  if workspace_exists "$workspace_name"; then
    terraform workspace select "$workspace_name" >/dev/null 2>&1

    # Remove shared resources from state so they won't be destroyed
    # (network and base volume are shared across all VMs)
    terraform state rm libvirt_network.default 2>/dev/null || true
    terraform state rm libvirt_volume.debian_base 2>/dev/null || true

    echo "Destroying Terraform resources..."
    if ! terraform destroy -auto-approve; then
      echo ""
      echo "ERROR: terraform destroy failed"
      echo ""
      echo "Workspace '$workspace_name' preserved for manual inspection."
      echo ""
      echo "To retry:"
      echo "  terraform workspace select $workspace_name"
      echo "  terraform destroy -auto-approve"
      echo "  terraform workspace select default"
      echo "  terraform workspace delete $workspace_name"
      echo ""
      echo "Or force cleanup (may leave orphaned resources):"
      echo "  terraform workspace select default"
      echo "  terraform workspace delete -force $workspace_name"
      echo ""
      return 1
    fi

    # Only delete workspace if destroy succeeded
    terraform workspace select default >/dev/null 2>&1
    terraform workspace delete "$workspace_name"

    # Clean up mount directory
    local mount_point="$HOME/.agent-vm-mounts/${vm_name}"
    if [ -d "$mount_point" ]; then
      rmdir "$mount_point" 2>/dev/null || true
    fi
  fi

  echo "VM destroyed: $vm_name"
}

function push_branch_to_vm {
  local vm_ip="$1"
  local branch_name="$2"
  local workspace_name="$3"
  local ssh_key="$SCRIPT_DIR/vm-ssh-key"

  echo "Pushing '$branch_name' to VM workspace '$workspace_name'..."

  cd "$(git rev-parse --show-toplevel)" || exit 1

  # Check if branch exists locally, create if not
  if ! git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Creating branch '$branch_name' from current HEAD..."
    git checkout -b "$branch_name"
  fi

  # Set up SSH key for git
  export GIT_SSH_COMMAND="ssh -i $ssh_key -o StrictHostKeyChecking=no"

  # Initialize git repo in VM workspace if needed
  ssh -i "$ssh_key" -o StrictHostKeyChecking=no "user@$vm_ip" bash -s "$workspace_name" <<'EOF'
    workspace_name="$1"
    if [ ! -d ~/workspace/$workspace_name/.git ]; then
      mkdir -p ~/workspace/$workspace_name
      cd ~/workspace/$workspace_name
      git init
      git config user.name "$(git config user.name || echo 'Agent User')"
      git config user.email "$(git config user.email || echo 'agent@localhost')"
    fi
EOF

  # Push branch to VM workspace
  if git push "ssh://user@${vm_ip}/home/user/workspace/$workspace_name" "$branch_name:$branch_name" 2>&1; then
    # Check out the branch in VM
    ssh -i "$ssh_key" -o StrictHostKeyChecking=no "user@$vm_ip" \
      "cd ~/workspace/$workspace_name && git checkout $branch_name" 2>/dev/null
    echo "✓ Branch '$branch_name' pushed to VM workspace"
  else
    echo "Error: Could not push branch '$branch_name' to workspace '$workspace_name'" >&2
    unset GIT_SSH_COMMAND
    return 1
  fi

  unset GIT_SSH_COMMAND
}

function fetch_branch_from_vm {
  local vm_ip="$1"
  local branch_name="$2"
  local workspace_name="$3"
  local ssh_key="$SCRIPT_DIR/vm-ssh-key"

  echo "Fetching '$branch_name' from VM workspace '$workspace_name'..."

  cd "$(git rev-parse --show-toplevel)" || exit 1

  # Check if workspace exists in VM
  if ! ssh -i "$ssh_key" -o StrictHostKeyChecking=no "user@$vm_ip" \
       "test -d ~/workspace/$workspace_name" 2>/dev/null; then
    echo "Error: Workspace '$workspace_name' does not exist in VM" >&2
    return 1
  fi

  # Check for uncommitted changes in VM (warn but continue)
  if ssh -i "$ssh_key" -o StrictHostKeyChecking=no "user@$vm_ip" \
     "cd ~/workspace/$workspace_name && ! git diff --quiet || ! git diff --cached --quiet" 2>/dev/null; then
    echo ""
    echo "⚠️  WARNING: VM workspace has uncommitted changes"
    echo "These will NOT be included in the fetch"
    echo "Fetching anyway..."
    echo ""
  fi

  # Set up SSH key for git
  export GIT_SSH_COMMAND="ssh -i $ssh_key -o StrictHostKeyChecking=no"

  # Fetch branch from VM
  if git fetch "ssh://user@${vm_ip}/home/user/workspace/$workspace_name" "$branch_name:$branch_name" 2>&1; then
    echo ""
    echo "✓ Branch '$branch_name' updated in main repo"
    echo ""
    echo "To view changes:"
    echo "  git checkout $branch_name"
    echo "  git log"
    echo ""
  else
    echo "Error: Could not fetch branch '$branch_name' from workspace '$workspace_name'" >&2
    unset GIT_SSH_COMMAND
    return 1
  fi

  unset GIT_SSH_COMMAND
}

function mount_vm_workspace {
  local vm_ip="$1"
  local ssh_key="$SCRIPT_DIR/vm-ssh-key"
  local mount_point="$HOME/.agent-vm-mounts/workspace"

  mkdir -p "$mount_point"

  # Check if already mounted
  if mountpoint -q "$mount_point" 2>/dev/null; then
    return 0
  fi

  echo "Mounting VM workspace via SSHFS..."

  # Check if sshfs is available
  if ! command -v sshfs >/dev/null 2>&1; then
    echo ""
    echo "⚠️  WARNING: sshfs not installed"
    echo ""
    echo "Install it to edit files on your host:"
    echo "  Debian/Ubuntu: sudo apt-get install sshfs"
    echo "  macOS: brew install sshfs"
    echo ""
    echo "Continuing without SSHFS mount..."
    return 1
  fi

  if sshfs -o StrictHostKeyChecking=no \
        -o reconnect \
        -o ServerAliveInterval=15 \
        -o ServerAliveCountMax=3 \
        -o follow_symlinks \
        -i "$ssh_key" \
        "user@${vm_ip}:/home/user/workspace" "$mount_point" 2>/dev/null; then
    echo "✓ Mounted at: $mount_point"
    return 0
  else
    echo "⚠️  Could not mount via SSHFS (continuing without mount)"
    return 1
  fi
}

function unmount_vm_workspace {
  local mount_point="$HOME/.agent-vm-mounts/workspace"

  if mountpoint -q "$mount_point" 2>/dev/null; then
    echo "Unmounting: $mount_point"
    fusermount -u "$mount_point" 2>/dev/null || umount "$mount_point" 2>/dev/null
    sleep 1
  fi
}

function list_workspaces {
  echo "Listing workspaces in agent-vm..."
  echo ""

  # Ensure VM is running
  if ! terraform show >/dev/null 2>&1; then
    echo "No VM exists. Create one with: ./agent-vm -b <branch>"
    return 0
  fi

  # Get VM details
  VM_IP=$(terraform output -raw vm_ip 2>/dev/null)
  VM_USER=$(terraform output -raw default_user 2>/dev/null)

  # Check VM is reachable
  if ! ssh -i "$SCRIPT_DIR/vm-ssh-key" -o ConnectTimeout=5 -o BatchMode=yes \
       -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" "exit" 2>/dev/null; then
    echo "VM exists but is not running. Start it with: ./agent-vm -b <branch>"
    return 0
  fi

  printf "%-30s %-20s\n" "WORKSPACE" "LAST MODIFIED"
  printf "%-30s %-20s\n" "---------" "-------------"

  ssh -i "$SCRIPT_DIR/vm-ssh-key" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
    "ls -lt ~/workspace/ 2>/dev/null | tail -n +2" | while read -r line; do
    # Extract name and date from ls -lt output
    workspace_name=$(echo "$line" | awk '{print $9}')
    modified_date=$(echo "$line" | awk '{print $6, $7, $8}')
    if [[ -n "$workspace_name" ]]; then
      printf "%-30s %-20s\n" "$workspace_name" "$modified_date"
    fi
  done

  echo ""
}

function clean_workspace {
  local branch_name="$1"
  local force="${2:-false}"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required for --clean" >&2
    exit 1
  fi

  # Get repo name
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use -b option" >&2
    exit 1
  fi

  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  WORKSPACE_NAME="${REPO_NAME}-${branch_name}"

  # Ensure VM is running
  ensure_vm_running

  VM_IP=$(terraform output -raw vm_ip 2>/dev/null)
  VM_USER=$(terraform output -raw default_user 2>/dev/null)
  SSH_KEY="$SCRIPT_DIR/vm-ssh-key"

  # Check if workspace exists
  if ! ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
       "test -d ~/workspace/$WORKSPACE_NAME" 2>/dev/null; then
    echo "Workspace does not exist: $WORKSPACE_NAME"
    exit 0
  fi

  # Check for uncommitted changes
  if ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
     "cd ~/workspace/$WORKSPACE_NAME && ! git diff --quiet || ! git diff --cached --quiet" 2>/dev/null; then
    echo ""
    echo "⚠️  WARNING: Workspace has uncommitted changes: $WORKSPACE_NAME"
    echo ""
  fi

  # Confirm deletion unless force
  if [[ "$force" != "true" ]]; then
    read -r -p "Remove workspace $WORKSPACE_NAME? (y/N) " response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      echo "Cancelled."
      exit 0
    fi
  fi

  echo "Removing workspace: $WORKSPACE_NAME"
  ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
    "rm -rf ~/workspace/$WORKSPACE_NAME"
  echo "✓ Workspace removed: $WORKSPACE_NAME"
}

function clean_all_workspaces {
  local force="${1:-false}"

  # Ensure VM is running
  ensure_vm_running

  VM_IP=$(terraform output -raw vm_ip 2>/dev/null)
  VM_USER=$(terraform output -raw default_user 2>/dev/null)
  SSH_KEY="$SCRIPT_DIR/vm-ssh-key"

  # List workspaces
  echo "Current workspaces:"
  list_workspaces

  # Confirm deletion unless force
  if [[ "$force" != "true" ]]; then
    read -r -p "Remove ALL workspaces from VM? (y/N) " response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      echo "Cancelled."
      exit 0
    fi
  fi

  echo "Removing all workspaces..."
  ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
    "rm -rf ~/workspace/*"
  echo "✓ All workspaces removed"
}

function ensure_vm_running {
  # Check if Terraform state exists
  if ! terraform show >/dev/null 2>&1; then
    echo "Error: No VM exists. Create one with: ./agent-vm -b <branch>" >&2
    exit 1
  fi

  # Check if VM is reachable
  VM_IP=$(terraform output -raw vm_ip 2>/dev/null)
  VM_USER=$(terraform output -raw default_user 2>/dev/null)

  if ! ssh -i "$SCRIPT_DIR/vm-ssh-key" -o ConnectTimeout=5 -o BatchMode=yes \
       -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" "exit" 2>/dev/null; then
    echo "VM exists but is not running. Starting..."
    terraform apply -auto-approve

    # Wait for ready
    echo "Waiting for VM to be ready..."
    local max_wait=120
    local elapsed=0
    while ! ssh -i "$SCRIPT_DIR/vm-ssh-key" -o ConnectTimeout=5 -o BatchMode=yes \
         -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" "exit" 2>/dev/null; do
      sleep 5
      elapsed=$((elapsed + 5))
      if [[ $elapsed -ge $max_wait ]]; then
        echo "ERROR: VM failed to start" >&2
        exit 1
      fi
    done
    echo "✓ VM is ready"
  fi
}

function warn_resource_overrides_ignored {
  if [[ -n "$MEMORY_OVERRIDE" || -n "$VCPU_OVERRIDE" || -n "$DISK_OVERRIDE" ]]; then
    echo "WARNING: VM already exists. Resource options ignored."
    echo "To apply new resources, destroy and recreate:"
    echo "  agent-vm -b $BRANCH_NAME --destroy"
    if [[ -n "$MEMORY_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --memory $MEMORY_OVERRIDE"
    fi
    if [[ -n "$VCPU_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --vcpu $VCPU_OVERRIDE"
    fi
    if [[ -n "$DISK_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --disk $DISK_OVERRIDE"
    fi
    echo ""
  fi
}

function cleanup_stopped_vms {
  echo "Cleaning up stopped VMs..."
  local cleaned_count=0

  # Use process substitution instead of pipe to avoid subshell
  # This preserves the cleaned_count variable updates
  while read -r ws; do
    # Skip empty lines
    [[ -z "$ws" ]] && continue

    terraform workspace select "$ws" >/dev/null 2>&1

    local vm_name="$ws"

    # Check if VM exists and is stopped
    if vm_domain_exists "$vm_name" && ! vm_is_running "$vm_name"; then
      echo "Destroying stopped VM: $vm_name"
      virsh destroy "$vm_name" 2>/dev/null || true
      virsh undefine "$vm_name" 2>/dev/null || true

      # Remove shared resources from state so they won't be destroyed
      terraform state rm libvirt_network.default 2>/dev/null || true
      terraform state rm libvirt_volume.debian_base 2>/dev/null || true

      # Destroy Terraform resources
      if ! terraform destroy -auto-approve >/dev/null 2>&1; then
        echo "  WARNING: terraform destroy failed for $vm_name, skipping workspace deletion"
        continue
      fi

      # Switch back and delete workspace (only if destroy succeeded)
      terraform workspace select default >/dev/null 2>&1
      terraform workspace delete "$ws" 2>/dev/null

      # Clean up mount directory
      local mount_point="$HOME/.agent-vm-mounts/${vm_name}"
      if [ -d "$mount_point" ]; then
        rmdir "$mount_point" 2>/dev/null || true
      fi

      cleaned_count=$((cleaned_count + 1))
    fi
  done < <(terraform workspace list 2>/dev/null | grep -v default | sed 's/^[* ] *//')

  # Return to default workspace
  terraform workspace select default >/dev/null 2>&1

  echo "Cleaned up $cleaned_count stopped VMs."
}

function list_vms {
  echo "Listing all VMs managed by agent-vm..."
  echo ""
  printf "%-30s %-15s %-15s\n" "VM NAME" "STATUS" "IP ADDRESS"
  printf "%-30s %-15s %-15s\n" "-------" "------" "----------"

  # List all workspaces except default
  terraform workspace list 2>/dev/null | grep -v default | sed 's/^[* ] *//' | \
    while read -r ws; do
      terraform workspace select "$ws" >/dev/null 2>&1

      local vm_name="$ws"
      local vm_ip
      vm_ip=$(terraform output -raw vm_ip 2>/dev/null || echo "N/A")

      local status="unknown"
      if vm_domain_exists "$vm_name"; then
        if vm_is_running "$vm_name"; then
          status="running"
        else
          status="stopped"
        fi
      else
        status="missing"
      fi

      printf "%-30s %-15s %-15s\n" "$vm_name" "$status" "$vm_ip"
    done

  # Return to default workspace
  terraform workspace select default >/dev/null 2>&1
  echo ""
}

function usage {
    cat - <<EOF
agent-vm: Single VM with multiple workspaces for AI coding agents

Usage: $0 [options] [-b <branch_name>] [-- command...]

Options:
  -b, --branch <name>         Branch name (required for most operations)
  --memory <MB>               VM memory in MB (default: 4096, creation only)
  --vcpu <count>              Virtual CPUs (default: 4, creation only)
  --disk <size>               Disk size like 60G (default: 40G, creation only)
  --list                      List all workspaces in VM
  --fetch                     Fetch changes from VM to host (requires -b)
  --push                      Force push branch from host to VM (requires -b)
  --clean                     Remove workspace from VM (requires -b)
  --clean-all                 Remove all workspaces (VM stays running)
  --destroy                   Destroy entire VM and all workspaces
  -h, --help                  Show this help

Arguments:
  command...                  Optional command to execute in VM

Workflow:
  1. ./agent-vm -b feature-auth       # Create VM, create workspace, mount SSHFS
  2. Edit files at ~/.agent-vm-mounts/workspace/myrepo-feature-auth/
  3. Build/test in VM SSH session
  4. Commit changes in VM
  5. ./agent-vm -b feature-auth --fetch    # Fetch changes back to host

File Sharing:
  * VM workspace: ~/workspace/<repo>-<branch>/
  * Host mount: ~/.agent-vm-mounts/workspace/
  * See all branches in one mount point
  * Real-time sync via SSHFS

Examples:
  $0 -b feature-auth                    # Create/connect to workspace
  $0 -b feature-auth --fetch            # Fetch VM changes to host
  $0 -b feature-auth --push             # Push host changes to VM
  $0 -b feature-auth -- claude          # Run claude directly
  $0 -b big-build --memory 16384        # Create VM with 16GB RAM
  $0 --list                             # List all workspaces
  $0 -b old-feature --clean             # Remove workspace
  $0 --destroy                          # Destroy VM

Storage:
  * SSHFS mount: ~/.agent-vm-mounts/workspace/
  * Terraform state: vm/.terraform/
  * SSH key: vm/vm-ssh-key

Multi-Workspace:
  * Multiple branches in same VM as separate directories
  * Open multiple terminals to different workspaces
  * VM persists after exit
EOF
}

# Parse command line options
BRANCH_NAME=""
VM_COMMAND=()
MEMORY_OVERRIDE=""
VCPU_OVERRIDE=""
DISK_OVERRIDE=""
ACTION=""  # list, fetch, push, clean, clean-all, destroy, or "" for connect

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--branch)
            BRANCH_NAME="$2"
            shift 2
            ;;
        --memory)
            MEMORY_OVERRIDE="$2"
            shift 2
            ;;
        --vcpu)
            VCPU_OVERRIDE="$2"
            shift 2
            ;;
        --disk)
            DISK_OVERRIDE="$2"
            shift 2
            ;;
        --list)
            ACTION="list"
            shift
            ;;
        --fetch)
            ACTION="fetch"
            shift
            ;;
        --push)
            ACTION="push"
            shift
            ;;
        --clean)
            ACTION="clean"
            shift
            ;;
        --clean-all)
            ACTION="clean-all"
            shift
            ;;
        --destroy)
            ACTION="destroy"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            VM_COMMAND=("$@")
            break
            ;;
        *)
            echo "Error: Unknown option: $1" >&2
            usage
            exit 1
            ;;
    esac
done

# Source common functions
# shellcheck source=vm-common.sh
# shellcheck disable=SC1091
source "$SCRIPT_DIR/vm-common.sh"

cd "$SCRIPT_DIR" || exit 1

# Handle list action
if [[ "$ACTION" == "list" ]]; then
  list_vms
  exit 0
fi

# Handle cleanup action
if [[ "$ACTION" == "cleanup" ]]; then
  cleanup_stopped_vms
  exit 0
fi

# Handle fetch action
if [[ "$ACTION" == "fetch" ]]; then
  if [[ -z "$BRANCH_NAME" ]]; then
    echo "Error: --fetch requires -b <branch_name>" >&2
    exit 1
  fi

  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use --fetch" >&2
    exit 1
  fi

  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  VM_NAME="${REPO_NAME}-${BRANCH_NAME}"

  # Check if VM exists
  if ! workspace_exists "$VM_NAME"; then
    echo "Error: No VM exists for branch '$BRANCH_NAME'" >&2
    echo "Create it first: ./agent-vm -b $BRANCH_NAME" >&2
    exit 1
  fi

  # Get VM IP
  terraform workspace select "$VM_NAME" >/dev/null 2>&1
  VM_IP=$(terraform output -raw vm_ip 2>/dev/null)

  # Fetch from VM
  fetch_branch_from_vm "$VM_IP" "$BRANCH_NAME"

  # Return to default workspace
  terraform workspace select default >/dev/null 2>&1

  exit 0
fi

# Stop and destroy require branch name
if [[ "$ACTION" == "stop" || "$ACTION" == "destroy" ]] && [[ -z "$BRANCH_NAME" ]]; then
  echo "Error: --stop and --destroy require -b <branch_name>" >&2
  exit 1
fi

# Handle stop/destroy actions
if [[ "$ACTION" == "stop" || "$ACTION" == "destroy" ]]; then
  # Determine VM naming (needed for stop/destroy)
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use -b option" >&2
    exit 1
  fi

  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  VM_NAME="${REPO_NAME}-${BRANCH_NAME}"

  if [[ "$ACTION" == "stop" ]]; then
    stop_vm "$VM_NAME"
    exit 0
  fi

  if [[ "$ACTION" == "destroy" ]]; then
    destroy_vm "$VM_NAME" "$VM_NAME"
    exit 0
  fi
fi

# Determine VM name from branch
if [[ -n "$BRANCH_NAME" ]]; then
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use -b option" >&2
    exit 1
  fi

  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  VM_NAME="${REPO_NAME}-${BRANCH_NAME}"
else
  echo "Error: -b <branch> is required" >&2
  exit 1
fi

# Detect network subnet (same logic as vm-up.sh)
if [ -z "$NETWORK_SUBNET" ]; then
  # Get the current VM's IP address (if any) on 192.168.x.x
  CURRENT_IP=$(ip -4 addr show | grep -oP '(?<=inet\s)192\.168\.\d+\.\d+(?=/)' | head -1)

  if [ -n "$CURRENT_IP" ]; then
    # Extract third octet from current IP
    CURRENT_THIRD_OCTET=$(echo "$CURRENT_IP" | cut -d. -f3)

    # Use different subnet: if we're on 122 or 123, use 200
    # Otherwise use current + 1 (wrapping at 255)
    if [ "$CURRENT_THIRD_OCTET" -eq 122 ] || [ "$CURRENT_THIRD_OCTET" -eq 123 ]; then
      NETWORK_SUBNET=200
      echo "Detected outer VM network: 192.168.$CURRENT_THIRD_OCTET.0/24"
      echo "Using subnet 192.168.$NETWORK_SUBNET.0/24 for nested VM"
    else
      NETWORK_SUBNET=$(( (CURRENT_THIRD_OCTET + 1) % 256 ))
      echo "Detected outer VM network: 192.168.$CURRENT_THIRD_OCTET.0/24"
      echo "Using subnet 192.168.$NETWORK_SUBNET.0/24 for nested VM"
    fi
  else
    # Not inside a VM on 192.168.x.x, use default
    NETWORK_SUBNET=123
  fi
fi

# Check if workspace exists
if workspace_exists "$VM_NAME"; then
  echo "VM workspace exists: $VM_NAME"

  # Select workspace
  terraform workspace select "$VM_NAME"

  # Check if VM domain exists
  if vm_domain_exists "$VM_NAME"; then
    if vm_is_running "$VM_NAME"; then
      echo "VM is already running: $VM_NAME"
      warn_resource_overrides_ignored
    else
      echo "VM exists but is stopped. Starting..."
      warn_resource_overrides_ignored
      virsh start "$VM_NAME"
      echo "VM started: $VM_NAME"
    fi
  else
    echo "Warning: Workspace exists but VM domain missing. Recreating..."
    # Workspace exists but VM doesn't - clean up and recreate

    # Remove shared resources from state so they won't be destroyed
    terraform state rm libvirt_network.default 2>/dev/null || true
    terraform state rm libvirt_volume.debian_base 2>/dev/null || true

    echo "Cleaning up orphaned workspace resources..."
    if ! terraform destroy -auto-approve; then
      echo ""
      echo "ERROR: Failed to destroy orphaned workspace resources"
      echo ""
      echo "Manual cleanup required:"
      echo "  terraform workspace select $VM_NAME"
      echo "  terraform state list"
      echo "  terraform destroy -auto-approve"
      echo ""
      echo "Or force deletion (may leave orphaned resources):"
      echo "  terraform workspace select default"
      echo "  terraform workspace delete -force $VM_NAME"
      echo ""
      exit 1
    fi

    terraform workspace select default
    terraform workspace delete "$VM_NAME"

    # Fall through to creation below
    CREATE_NEW_VM=1
  fi
else
  CREATE_NEW_VM=1
fi

# Create new VM if needed
if [[ "${CREATE_NEW_VM:-0}" == "1" ]]; then
  echo "Creating new VM: $VM_NAME"

  # Create workspace
  terraform workspace new "$VM_NAME"

  # Allocate IP and provision VM under exclusive lock to prevent race conditions
  # Lock is held from IP selection through terraform apply completion
  VM_IP_FILE="/tmp/agent-vm-ip-$$"

  flock -x -w 30 /tmp/agent-vm-ip-allocation.lock bash <<FLOCK_SCRIPT
    set -e -o pipefail

    # Change to terraform directory
    cd "$SCRIPT_DIR" || exit 1

    # Source common functions
    source "$SCRIPT_DIR/vm-common.sh"

    # Find available IP (lock is held by flock)
    find_available_ip "$SCRIPT_DIR" "$NETWORK_SUBNET"
    echo "Allocated IP: \$VM_IP"

    # Save IP for parent process
    echo "\$VM_IP" > "$VM_IP_FILE"

    # Build terraform variables
    TERRAFORM_VARS=(
      -var="vm_name=$VM_NAME"
      -var="vm_hostname=$VM_NAME"
      -var="vm_ip=\$VM_IP"
      -var="network_subnet_third_octet=$NETWORK_SUBNET"
      -var="user_uid=$(id -u)"
      -var="user_gid=$(id -g)"
    )

    # Add resource overrides if provided
    if [[ -n "$MEMORY_OVERRIDE" ]]; then
      TERRAFORM_VARS+=(-var="vm_memory=$MEMORY_OVERRIDE")
    fi
    if [[ -n "$VCPU_OVERRIDE" ]]; then
      TERRAFORM_VARS+=(-var="vm_vcpu=$VCPU_OVERRIDE")
    fi
    if [[ -n "$DISK_OVERRIDE" ]]; then
      DISK_BYTES=\$(numfmt --from=iec "$DISK_OVERRIDE")
      TERRAFORM_VARS+=(-var="vm_disk_size=\$DISK_BYTES")
    fi

    # Add GCP credentials if available
    GCP_CREDS_DEFAULT="$HOME/.config/gcloud/application_default_credentials.json"
    if [[ -n "$GOOGLE_APPLICATION_CREDENTIALS" ]]; then
      GCP_CREDS_PATH="$GOOGLE_APPLICATION_CREDENTIALS"
    else
      GCP_CREDS_PATH="\$GCP_CREDS_DEFAULT"
    fi

    if [[ -f "\$GCP_CREDS_PATH" ]]; then
      echo "Injecting GCP credentials from: \$GCP_CREDS_PATH"
      TERRAFORM_VARS+=(-var="gcp_service_account_key_path=\$GCP_CREDS_PATH")

      if [[ -n "$ANTHROPIC_VERTEX_PROJECT_ID" ]]; then
        TERRAFORM_VARS+=(-var="vertex_project_id=$ANTHROPIC_VERTEX_PROJECT_ID")
      fi
      if [[ -n "$CLOUD_ML_REGION" ]]; then
        TERRAFORM_VARS+=(-var="vertex_region=$CLOUD_ML_REGION")
      fi
    fi

    # Initialize terraform if needed
    if [[ ! -d ".terraform" ]] || [[ ! -f ".terraform.lock.hcl" ]]; then
      echo "Initializing Terraform..."
      terraform init
    fi

    # Import shared resources if they exist in libvirt but not in state
    # This allows multiple workspaces to share the network and base image
    echo "Checking if shared resources need to be imported..."
    if ! terraform state list 2>/dev/null | grep -q "libvirt_network.default"; then
      echo "Network not in state, checking if it exists in libvirt..."
      NET_UUID=\$(virsh --connect qemu:///system net-uuid default 2>/dev/null || true)
      if [ -n "\$NET_UUID" ]; then
        echo "Importing existing network 'default' (UUID: \$NET_UUID) into workspace..."
        terraform import libvirt_network.default "\$NET_UUID" || echo "Import failed, will try to create"
      else
        echo "Network doesn't exist yet, will create"
      fi
    else
      echo "Network already in state"
    fi

    if ! terraform state list 2>/dev/null | grep -q "libvirt_volume.debian_base"; then
      echo "Base volume not in state, checking if it exists in libvirt..."
      if virsh --connect qemu:///system vol-info debian-13-base.qcow2 --pool default &>/dev/null; then
        echo "Importing existing base volume 'debian-13-base.qcow2' into workspace..."
        VOL_KEY=\$(virsh --connect qemu:///system vol-key debian-13-base.qcow2 --pool default 2>/dev/null || true)
        terraform import libvirt_volume.debian_base "\$VOL_KEY" || echo "Import failed, will try to create"
      else
        echo "Base volume doesn't exist yet, will create"
      fi
    else
      echo "Base volume already in state"
    fi

    # Apply terraform (lock prevents other processes from allocating same IP)
    echo "Provisioning VM with Terraform..."
    terraform apply -auto-approve "\${TERRAFORM_VARS[@]}"
FLOCK_SCRIPT

  # Read VM_IP from temp file
  VM_IP=$(cat "$VM_IP_FILE")
  rm -f "$VM_IP_FILE"

  # Remove old SSH key from known_hosts
  ssh-keygen -R "$VM_IP" 2>/dev/null || true

  echo "VM created successfully: $VM_NAME"
fi

# Get VM IP and user
VM_IP=$(terraform output -raw vm_ip 2>/dev/null)
VM_USER=$(terraform output -raw default_user 2>/dev/null)
SSH_KEY="$SCRIPT_DIR/vm-ssh-key"

# Wait for VM to be ready
echo "Waiting for VM to be ready..."
MAX_WAIT=300
ELAPSED=0
while ! ssh -i "$SSH_KEY" -o ConnectTimeout=5 -o BatchMode=yes \
     -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" "exit" 2>/dev/null; do
  sleep 5
  ELAPSED=$((ELAPSED + 5))
  if [[ $ELAPSED -ge $MAX_WAIT ]]; then
    echo "ERROR: VM failed to start within 5 minutes" >&2
    echo "Check cloud-init logs:"
    echo "  ssh -i $SSH_KEY root@$VM_IP 'tail -100 /var/log/cloud-init-output.log'"
    exit 1
  fi
done

# Push branch to VM
push_branch_to_vm "$VM_IP" "$BRANCH_NAME"

# Mount VM worktree via SSHFS (non-fatal if it fails)
mount_vm_workspace "$VM_IP" || true

# Connect to VM
echo "Connecting to VM: $VM_NAME (IP: $VM_IP)"
echo ""

if [[ ${#VM_COMMAND[@]} -gt 0 ]]; then
  # Execute command and exit
  ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
    "cd /worktree 2>/dev/null || cd ~; ${VM_COMMAND[*]}"
else
  # Interactive session
  ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$VM_USER@$VM_IP" \
    -t "cd /worktree 2>/dev/null || cd ~; exec bash -l"
fi
