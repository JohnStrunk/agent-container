#!/bin/bash

set -e -o pipefail

SCRIPT_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
VM_NAME="agent-vm"
VM_HOST="lima-${VM_NAME}"
SSH_CONFIG="$HOME/.lima/${VM_NAME}/ssh.config"
MOUNT_DIR="$HOME/.agent-vm-mounts/workspace"

# Detect platform for unmount command
PLATFORM="$(uname -s)"
case "$PLATFORM" in
  Linux*)
    UNMOUNT_CMD="fusermount -u"
    ;;
  Darwin*)
    UNMOUNT_CMD="umount"
    ;;
  *)
    echo "Unsupported platform: $PLATFORM"
    exit 1
    ;;
esac

function vm_exists {
  limactl list --format json 2>/dev/null | grep -q "\"name\":\"$VM_NAME\""
}

function vm_is_running {
  if ! vm_exists; then
    return 1
  fi
  limactl list --format json 2>/dev/null | grep "\"name\":\"$VM_NAME\"" | grep -q "\"status\":\"Running\""
}

function unmount_vm_workspace {
  if mountpoint -q "$MOUNT_DIR" 2>/dev/null; then
    echo "Unmounting: $MOUNT_DIR"
    $UNMOUNT_CMD "$MOUNT_DIR" 2>/dev/null || true
    sleep 1
  fi
}

function mount_vm_workspace {
  mkdir -p "$MOUNT_DIR"

  # Check if already mounted
  if mountpoint -q "$MOUNT_DIR" 2>/dev/null; then
    return 0
  fi

  echo "Mounting VM workspace via SSHFS..."

  # Check if sshfs is available
  if ! command -v sshfs >/dev/null 2>&1; then
    echo ""
    echo "⚠️  WARNING: sshfs not installed"
    echo ""
    echo "Install it to edit files on your host:"
    echo "  Linux (Debian/Ubuntu): sudo apt-get install sshfs"
    echo "  macOS: brew install macfuse && brew install sshfs"
    echo ""
    echo "Continuing without SSHFS mount..."
    return 1
  fi

  # Mount with Lima SSH config
  if sshfs -F "$SSH_CONFIG" \
        -o reconnect \
        -o ServerAliveInterval=15 \
        -o ServerAliveCountMax=3 \
        -o follow_symlinks \
        "${VM_HOST}:/home/user/workspace" "$MOUNT_DIR"; then
    echo "✓ Mounted at: $MOUNT_DIR"
    return 0
  else
    echo "⚠️  Could not mount via SSHFS (continuing without mount)"
    echo "   Mount point: $MOUNT_DIR"
    echo "   VM host: $VM_HOST"
    return 1
  fi
}

function start_vm {
  local memory="$1"
  local vcpu="$2"
  local template_path="$SCRIPT_DIR/agent-vm.yaml"

  # Check if VM exists
  if vm_exists; then
    echo "VM already exists: $VM_NAME"

    # Warn if resource overrides provided
    if [[ -n "$memory" || -n "$vcpu" ]]; then
      echo "WARNING: VM already exists. Resource options ignored."
      echo "To apply new resources:"
      echo "  ./agent-vm destroy"
      if [[ -n "$memory" ]]; then
        echo "  ./agent-vm start --memory $memory"
      fi
      if [[ -n "$vcpu" ]]; then
        echo "  ./agent-vm start --vcpu $vcpu"
      fi
      echo ""
    fi

    # Start if stopped
    if ! vm_is_running; then
      echo "Starting VM: $VM_NAME"
      limactl start "$VM_NAME"
    else
      echo "VM is already running"
    fi
    return 0
  fi

  echo "Creating new VM: $VM_NAME"

  # Handle resource overrides
  if [[ -n "$memory" || -n "$vcpu" ]]; then
    # Create temporary template with overrides
    local temp_template
    temp_template=$(mktemp)
    cp "$template_path" "$temp_template"

    if [[ -n "$memory" ]]; then
      sed -i.bak "s/^memory:.*/memory: \"${memory}GiB\"/" "$temp_template"
    fi
    if [[ -n "$vcpu" ]]; then
      sed -i.bak "s/^cpus:.*/cpus: $vcpu/" "$temp_template"
    fi

    # Clean up backup files
    rm -f "${temp_template}.bak"

    template_path="$temp_template"
  fi

  # Detect and export GCP credentials for provisioning
  local gcp_creds_path=""
  if [[ -n "${GOOGLE_APPLICATION_CREDENTIALS:-}" ]]; then
    gcp_creds_path="$GOOGLE_APPLICATION_CREDENTIALS"
  elif [[ -f "$HOME/.config/gcloud/application_default_credentials.json" ]]; then
    gcp_creds_path="$HOME/.config/gcloud/application_default_credentials.json"
  fi

  if [[ -n "$gcp_creds_path" && -f "$gcp_creds_path" ]]; then
    echo "Found GCP credentials at: $gcp_creds_path"
    local gcp_creds_json
    gcp_creds_json=$(cat "$gcp_creds_path")
    export GCP_CREDENTIALS_JSON="$gcp_creds_json"
    export VERTEX_PROJECT_ID="${ANTHROPIC_VERTEX_PROJECT_ID:-}"
    export VERTEX_REGION="${CLOUD_ML_REGION:-us-central1}"
  fi

  # Start VM with Lima
  limactl start --name="$VM_NAME" "$template_path"

  # Clean up temporary template if created
  if [[ "$template_path" != "$SCRIPT_DIR/agent-vm.yaml" ]]; then
    rm -f "$template_path"
  fi

  echo "✓ VM created successfully: $VM_NAME"
}

function destroy_vm {
  echo "Destroying VM and all workspaces..."

  # Unmount SSHFS
  unmount_vm_workspace

  # Check if VM exists
  if ! vm_exists; then
    echo "No VM exists."
    return 0
  fi

  # Stop and delete VM
  echo "Stopping and deleting VM..."
  if vm_is_running; then
    limactl stop "$VM_NAME" 2>/dev/null || true
  fi
  limactl delete "$VM_NAME" 2>/dev/null || true

  # Clean up mount directory
  if [ -d "$MOUNT_DIR" ]; then
    rmdir "$MOUNT_DIR" 2>/dev/null || true
  fi

  echo "✓ VM destroyed"
}

function show_status {
  echo "VM Status:"
  echo ""

  if ! vm_exists; then
    echo "  State: Does not exist"
    echo ""
    echo "Create VM with: ./agent-vm start"
    return 0
  fi

  if vm_is_running; then
    echo "  State: Running"
  else
    echo "  State: Stopped"
  fi

  # Get VM info from limactl
  local vm_info
  vm_info=$(limactl list --format json 2>/dev/null | grep -A 20 "\"name\":\"$VM_NAME\"" || echo "")

  # Extract resources if available
  if [[ -n "$vm_info" ]]; then
    local cpus memory disk
    cpus=$(echo "$vm_info" | grep -o '"cpus":[0-9]*' | cut -d: -f2 || echo "N/A")
    memory=$(echo "$vm_info" | grep -o '"memory":[0-9]*' | cut -d: -f2 || echo "N/A")
    disk=$(echo "$vm_info" | grep -o '"disk":[0-9]*' | cut -d: -f2 || echo "N/A")

    echo "  Resources:"
    echo "    CPUs: $cpus"
    if [[ "$memory" != "N/A" ]]; then
      # Convert bytes to GiB
      memory_gib=$((memory / 1024 / 1024 / 1024))
      echo "    Memory: ${memory_gib} GiB"
    else
      echo "    Memory: N/A"
    fi
    if [[ "$disk" != "N/A" ]]; then
      # Convert bytes to GiB
      disk_gib=$((disk / 1024 / 1024 / 1024))
      echo "    Disk: ${disk_gib} GiB"
    else
      echo "    Disk: N/A"
    fi
  fi

  echo ""

  # Show SSHFS mount status
  if mountpoint -q "$MOUNT_DIR" 2>/dev/null; then
    echo "  SSHFS: Mounted at $MOUNT_DIR"
  else
    echo "  SSHFS: Not mounted"
  fi

  echo ""

  # List workspaces if VM is running
  if vm_is_running; then
    echo "Workspaces:"
    echo ""

    # Wait for SSH to be ready
    if ! ssh -F "$SSH_CONFIG" -o ConnectTimeout=5 -o BatchMode=yes \
         "$VM_HOST" "exit" 2>/dev/null; then
      echo "  (VM is starting, SSH not ready yet)"
      return 0
    fi

    printf "  %-30s %-20s %-20s\n" "NAME" "BRANCH" "LAST MODIFIED"
    printf "  %-30s %-20s %-20s\n" "----" "------" "-------------"

    # Get workspace list
    local workspace_list
    workspace_list=$(ssh -F "$SSH_CONFIG" "$VM_HOST" \
      "ls -lt ~/workspace/ 2>/dev/null | tail -n +2" 2>/dev/null || echo "")

    if [[ -z "$workspace_list" ]]; then
      echo "  (no workspaces)"
      return 0
    fi

    while read -r line; do
      if [[ -z "$line" ]]; then
        continue
      fi

      # Extract name and date from ls -lt output
      local workspace_name modified_date branch
      workspace_name=$(echo "$line" | awk '{print $9}')
      modified_date=$(echo "$line" | awk '{print $6, $7, $8}')

      if [[ -n "$workspace_name" ]]; then
        # Get current branch
        branch=$(ssh -F "$SSH_CONFIG" "$VM_HOST" \
          "cd ~/workspace/$workspace_name 2>/dev/null && git rev-parse --abbrev-ref HEAD 2>/dev/null" \
          2>/dev/null || echo "N/A")

        printf "  %-30s %-20s %-20s\n" "$workspace_name" "$branch" "$modified_date"
      fi
    done <<< "$workspace_list"
  fi
}

function push_branch_to_vm {
  local branch_name="$1"
  local workspace_name="$2"

  echo "Pushing '$branch_name' to VM workspace '$workspace_name'..."

  cd "$(git rev-parse --show-toplevel)" || exit 1

  # Check if branch exists locally, create if not
  if ! git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Creating branch '$branch_name' from current HEAD..."
    git branch "$branch_name"
  fi

  # Set up SSH key for git
  export GIT_SSH_COMMAND="ssh -F $SSH_CONFIG -o StrictHostKeyChecking=no"

  # Initialize git repo in VM workspace if needed
  ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" bash -s "$workspace_name" <<'EOF'
    workspace_name="$1"
    if [ ! -d ~/workspace/$workspace_name/.git ]; then
      mkdir -p ~/workspace/$workspace_name
      cd ~/workspace/$workspace_name
      git init
      git config user.name "$(git config user.name || echo 'Agent User')"
      git config user.email "$(git config user.email || echo 'agent@localhost')"
    fi
EOF

  # Push branch to VM workspace
  if git push "ssh://${VM_HOST}/home/user/workspace/$workspace_name" "$branch_name:$branch_name" 2>&1; then
    # Check out the branch in VM
    ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
      "cd ~/workspace/$workspace_name && git checkout $branch_name" 2>/dev/null
    echo "✓ Branch '$branch_name' pushed to VM workspace"
  else
    echo "Error: Could not push branch '$branch_name' to workspace '$workspace_name'" >&2
    unset GIT_SSH_COMMAND
    return 1
  fi

  unset GIT_SSH_COMMAND
}

function fetch_branch_from_vm {
  local branch_name="$1"
  local workspace_name="$2"

  echo "Fetching '$branch_name' from VM workspace '$workspace_name'..."

  cd "$(git rev-parse --show-toplevel)" || exit 1

  # Check if workspace exists in VM
  if ! ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
       "test -d ~/workspace/$workspace_name" 2>/dev/null; then
    echo "Error: Workspace '$workspace_name' does not exist in VM" >&2
    return 1
  fi

  # Check for uncommitted changes in VM (warn but continue)
  if ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
     "cd ~/workspace/$workspace_name && ! git diff --quiet || ! git diff --cached --quiet" 2>/dev/null; then
    echo ""
    echo "⚠️  WARNING: VM workspace has uncommitted changes"
    echo "These will NOT be included in the fetch"
    echo "Fetching anyway..."
    echo ""
  fi

  # Set up SSH key for git
  export GIT_SSH_COMMAND="ssh -F $SSH_CONFIG -o StrictHostKeyChecking=no"

  # Check if branch is currently checked out
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

  # Fetch branch from VM
  if [ "$current_branch" = "$branch_name" ]; then
    # Branch is checked out - use pull to update working tree
    echo "Branch '$branch_name' is currently checked out - using git pull..."
    if git pull "ssh://${VM_HOST}/home/user/workspace/$workspace_name" "$branch_name" 2>&1; then
      echo ""
      echo "✓ Branch '$branch_name' updated and working tree synchronized"
      echo ""
      echo "To view changes:"
      echo "  git log"
      echo ""
    else
      echo "Error: Could not pull branch '$branch_name' from workspace '$workspace_name'" >&2
      unset GIT_SSH_COMMAND
      return 1
    fi
  else
    # Branch is not checked out - use fetch to update ref only
    if git fetch "ssh://${VM_HOST}/home/user/workspace/$workspace_name" "$branch_name:$branch_name" 2>&1; then
      echo ""
      echo "✓ Branch '$branch_name' updated in main repo"
      echo ""
      echo "To view changes:"
      echo "  git checkout $branch_name"
      echo "  git log"
      echo ""
    else
      echo "Error: Could not fetch branch '$branch_name' from workspace '$workspace_name'" >&2
      unset GIT_SSH_COMMAND
      return 1
    fi
  fi

  unset GIT_SSH_COMMAND
}

function install_precommit_hooks {
  local workspace_name="$1"

  # Check if .pre-commit-config.yaml exists in workspace
  if ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
     "test -f ~/workspace/$workspace_name/.pre-commit-config.yaml" 2>/dev/null; then

    # Install pre-commit hooks
    if ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
       "cd ~/workspace/$workspace_name && pre-commit install" 2>/dev/null; then
      echo "✓ Pre-commit hooks installed"
    else
      echo ""
      echo "⚠️  WARNING: Could not install pre-commit hooks"
      echo "You can install them manually: cd ~/workspace/$workspace_name && pre-commit install"
      echo ""
    fi
  fi
}

function clean_workspace {
  local branch_name="$1"
  local force="${2:-false}"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required for clean" >&2
    exit 1
  fi

  # Get repo name
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use branch operations" >&2
    exit 1
  fi

  local repo_name workspace_name
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  workspace_name="${repo_name}-${branch_name}"

  # Ensure VM is running
  ensure_vm_running

  # Check if workspace exists
  if ! ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
       "test -d ~/workspace/$workspace_name" 2>/dev/null; then
    echo "Workspace does not exist: $workspace_name"
    return 0
  fi

  # Check for uncommitted changes
  if ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
     "cd ~/workspace/$workspace_name && ! git diff --quiet || ! git diff --cached --quiet" 2>/dev/null; then
    echo ""
    echo "⚠️  WARNING: Workspace has uncommitted changes: $workspace_name"
    echo ""
  fi

  # Confirm deletion unless force
  if [[ "$force" != "true" ]]; then
    read -r -p "Remove workspace $workspace_name? (y/N) " response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      echo "Cancelled."
      return 0
    fi
  fi

  echo "Removing workspace: $workspace_name"
  ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
    "rm -rf ~/workspace/$workspace_name"
  echo "✓ Workspace removed: $workspace_name"
}

function clean_all_workspaces {
  # Ensure VM is running
  ensure_vm_running

  # Show current workspaces
  echo "Current workspaces:"
  show_status
  echo ""

  # Confirm deletion
  read -r -p "Remove ALL workspaces from VM? (y/N) " response
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    echo "Cancelled."
    return 0
  fi

  echo "Removing all workspaces..."
  ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
    "rm -rf ~/workspace/*"
  echo "✓ All workspaces removed"
}

function ensure_vm_running {
  if ! vm_exists; then
    echo "Error: No VM exists. Create one with: ./agent-vm start" >&2
    exit 1
  fi

  if ! vm_is_running; then
    echo "VM is stopped. Starting..."
    limactl start "$VM_NAME"

    # Wait for SSH to be ready
    echo "Waiting for VM to be ready..."
    local max_wait=300
    local elapsed=0
    while ! ssh -F "$SSH_CONFIG" -o ConnectTimeout=5 -o BatchMode=yes \
         "$VM_HOST" "exit" 2>/dev/null; do
      sleep 5
      elapsed=$((elapsed + 5))
      if [[ $elapsed -ge $max_wait ]]; then
        echo "ERROR: VM failed to start within 5 minutes" >&2
        exit 1
      fi
    done
    echo "✓ VM is ready"
  fi
}

function connect_to_vm {
  local branch_name="$1"
  shift
  local vm_command=("$@")

  # Ensure VM is running
  ensure_vm_running

  # Build environment variable exports from common/packages/envvars.txt
  local env_exports=""
  local envvars_file="$SCRIPT_DIR/../common/packages/envvars.txt"
  if [[ -f "$envvars_file" ]]; then
    while IFS= read -r var || [[ -n "$var" ]]; do
      # Skip empty lines and comments
      [[ -z "$var" || "$var" =~ ^# ]] && continue
      # Only export if variable is set in host environment
      if [[ -n "${!var:-}" ]]; then
        # Escape special characters for shell
        local escaped_value
        escaped_value=$(printf '%s' "${!var}" | sed "s/'/'\\\\''/g")
        env_exports+="export $var='$escaped_value'; "
      fi
    done < "$envvars_file"
  fi

  # If no branch specified, connect directly to VM
  if [[ -z "$branch_name" ]]; then
    echo "Connecting to VM: $VM_NAME"
    echo ""

    if [[ ${#vm_command[@]} -gt 0 ]]; then
      ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
        "${env_exports}cd ~ 2>/dev/null || cd ~; ${vm_command[*]}"
    else
      ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
        -t "${env_exports}cd ~ 2>/dev/null || cd ~; exec bash -l"
    fi
    return 0
  fi

  # Get repo name and workspace name
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "Error: Must be in a git repository to use branch operations" >&2
    exit 1
  fi

  local repo_name workspace_name
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  workspace_name="${repo_name}-${branch_name}"

  # Mount workspace via SSHFS (if not already mounted)
  mount_vm_workspace || true

  # Check if workspace exists
  local workspace_exists=false
  if ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
     "test -d ~/workspace/$workspace_name" 2>/dev/null; then
    workspace_exists=true
  fi

  # If workspace doesn't exist, push branch
  if [[ "$workspace_exists" == "false" ]]; then
    echo "Creating new workspace: $workspace_name"
    push_branch_to_vm "$branch_name" "$workspace_name"
    install_precommit_hooks "$workspace_name"
  else
    echo "Using existing workspace: $workspace_name"
  fi

  # Connect to VM
  echo "Connecting to VM workspace: $workspace_name"
  echo ""

  if [[ ${#vm_command[@]} -gt 0 ]]; then
    ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
      "${env_exports}cd ~/workspace/$workspace_name 2>/dev/null || cd ~; ${vm_command[*]}"
  else
    ssh -F "$SSH_CONFIG" -o StrictHostKeyChecking=no "$VM_HOST" \
      -t "${env_exports}cd ~/workspace/$workspace_name 2>/dev/null || cd ~; exec bash -l"
  fi
}

function usage {
    cat - <<EOF
agent-vm: Single VM with multiple workspaces for AI coding agents (Lima-based)

Usage: $0 <command> [options]

Commands:
  start [--memory M --vcpu N]     Create/start VM (resource options only at creation)
  destroy                         Delete VM entirely and all workspaces
  status                          Show VM state, workspaces, and mounts
  connect [branch]                Connect to workspace or VM directly (creates if needed)
  push <branch>                   Push branch from host to VM workspace
  fetch <branch>                  Fetch branch from VM workspace to host
  clean <branch>                  Delete specific workspace
  clean-all                       Delete all workspaces (VM stays running)

Options:
  --memory <GB>                   VM memory in GB (default: 8, creation only)
  --vcpu <count>                  Virtual CPUs (default: 4, creation only)
  -h, --help                      Show this help

Workflow:
  1. ./agent-vm start                         # Create/start VM
  2. ./agent-vm connect feature-auth          # Create workspace, mount SSHFS
  3. Edit files at ~/.agent-vm-mounts/workspace/<repo>-<branch>/
  4. Build/test in VM SSH session
  5. Commit changes in VM
  6. ./agent-vm fetch feature-auth            # Fetch changes back to host

File Sharing:
  * VM workspace: ~/workspace/<repo>-<branch>/
  * Host mount: ~/.agent-vm-mounts/workspace/
  * See all branches in one mount point
  * Real-time sync via SSHFS

Examples:
  $0 start                                # Create/start VM
  $0 start --memory 16 --vcpu 8           # Create VM with 16GB RAM, 8 CPUs
  $0 status                               # Show VM state and workspaces
  $0 connect feature-auth                 # Create/connect to workspace
  $0 connect                              # Connect directly to VM (no workspace)
  $0 push feature-auth                    # Push host changes to VM
  $0 fetch feature-auth                   # Fetch VM changes to host
  $0 connect feature-auth -- claude       # Run claude directly
  $0 clean old-feature                    # Remove workspace
  $0 clean-all                            # Remove all workspaces
  $0 destroy                              # Destroy VM

Storage:
  * SSHFS mount: ~/.agent-vm-mounts/workspace/
  * Lima state: ~/.lima/agent-vm/
  * SSH config: ~/.lima/agent-vm/ssh.config

Multi-Workspace:
  * Multiple branches in same VM as separate directories
  * Open multiple terminals to different workspaces
  * VM persists after exit
EOF
}

# Parse command line
COMMAND=""
BRANCH_NAME=""
VM_COMMAND=()
MEMORY=""
VCPU=""

if [[ $# -eq 0 ]]; then
  usage
  exit 1
fi

# First argument is the command
COMMAND="$1"
shift

# Parse remaining arguments based on command
case "$COMMAND" in
  start)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --memory)
          MEMORY="$2"
          shift 2
          ;;
        --vcpu)
          VCPU="$2"
          shift 2
          ;;
        -h|--help)
          usage
          exit 0
          ;;
        *)
          echo "Error: Unknown option for start: $1" >&2
          usage
          exit 1
          ;;
      esac
    done
    start_vm "$MEMORY" "$VCPU"
    ;;

  destroy)
    if [[ $# -gt 0 ]]; then
      echo "Error: destroy command takes no arguments" >&2
      usage
      exit 1
    fi
    destroy_vm
    ;;

  status)
    if [[ $# -gt 0 ]]; then
      echo "Error: status command takes no arguments" >&2
      usage
      exit 1
    fi
    show_status
    ;;

  connect)
    # Optional branch name, then optional -- command
    if [[ $# -gt 0 && "$1" != "--" ]]; then
      BRANCH_NAME="$1"
      shift
    fi

    if [[ $# -gt 0 && "$1" == "--" ]]; then
      shift
      VM_COMMAND=("$@")
    elif [[ $# -gt 0 ]]; then
      echo "Error: Unexpected arguments after branch name (use -- before command)" >&2
      usage
      exit 1
    fi

    connect_to_vm "$BRANCH_NAME" "${VM_COMMAND[@]}"
    ;;

  push)
    if [[ $# -ne 1 ]]; then
      echo "Error: push requires exactly one argument: <branch>" >&2
      usage
      exit 1
    fi
    BRANCH_NAME="$1"

    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
      echo "Error: Must be in a git repository to use push" >&2
      exit 1
    fi

    repo_name="$(basename "$(git rev-parse --show-toplevel)")"
    workspace_name="${repo_name}-${BRANCH_NAME}"

    ensure_vm_running
    push_branch_to_vm "$BRANCH_NAME" "$workspace_name"
    ;;

  fetch)
    if [[ $# -ne 1 ]]; then
      echo "Error: fetch requires exactly one argument: <branch>" >&2
      usage
      exit 1
    fi
    BRANCH_NAME="$1"

    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
      echo "Error: Must be in a git repository to use fetch" >&2
      exit 1
    fi

    repo_name="$(basename "$(git rev-parse --show-toplevel)")"
    workspace_name="${repo_name}-${BRANCH_NAME}"

    ensure_vm_running
    fetch_branch_from_vm "$BRANCH_NAME" "$workspace_name"
    ;;

  clean)
    if [[ $# -ne 1 ]]; then
      echo "Error: clean requires exactly one argument: <branch>" >&2
      usage
      exit 1
    fi
    BRANCH_NAME="$1"
    clean_workspace "$BRANCH_NAME"
    ;;

  clean-all)
    if [[ $# -gt 0 ]]; then
      echo "Error: clean-all takes no arguments" >&2
      usage
      exit 1
    fi
    clean_all_workspaces
    ;;

  -h|--help)
    usage
    exit 0
    ;;

  *)
    echo "Error: Unknown command: $COMMAND" >&2
    echo ""
    usage
    exit 1
    ;;
esac
