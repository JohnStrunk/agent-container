#!/bin/bash

set -e -o pipefail

WORKTREE_BASE_DIR=~/src/worktrees
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

function stop_vm {
  local vm_name="$1"

  if ! vm_domain_exists "$vm_name"; then
    echo "Error: VM does not exist: $vm_name" >&2
    exit 1
  fi

  if ! vm_is_running "$vm_name"; then
    echo "VM is already stopped: $vm_name"
    exit 0
  fi

  echo "Stopping VM: $vm_name"
  virsh shutdown "$vm_name"
  echo "VM stopped (graceful shutdown initiated)."
}

function destroy_vm {
  local vm_name="$1"
  local workspace_name="$2"

  echo "Destroying VM: $vm_name"

  # Stop and destroy domain if exists
  if vm_domain_exists "$vm_name"; then
    virsh destroy "$vm_name" 2>/dev/null || true
    virsh undefine "$vm_name" 2>/dev/null || true
  fi

  # Switch to workspace and destroy Terraform resources
  if workspace_exists "$workspace_name"; then
    terraform workspace select "$workspace_name" >/dev/null 2>&1
    terraform destroy -auto-approve

    # Delete workspace
    terraform workspace select default >/dev/null 2>&1
    terraform workspace delete "$workspace_name"
  fi

  echo "VM destroyed: $vm_name"
}

function setup_worktree {
  local worktree_dir="$1"
  local branch_name="$2"

  if [[ -d "$worktree_dir" ]]; then
    echo "Worktree for branch '$branch_name' already exists at $worktree_dir."
    return 0
  fi

  # Check if branch exists
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Adding worktree for existing branch '$branch_name'..."
    git worktree add "$worktree_dir" "$branch_name"
  else
    echo "Creating branch '$branch_name' from current HEAD and adding worktree..."
    git worktree add -b "$branch_name" "$worktree_dir"
  fi
}

function warn_resource_overrides_ignored {
  if [[ -n "$MEMORY_OVERRIDE" || -n "$VCPU_OVERRIDE" || -n "$DISK_OVERRIDE" ]]; then
    echo "WARNING: VM already exists. Resource options ignored."
    echo "To apply new resources, destroy and recreate:"
    echo "  agent-vm -b $BRANCH_NAME --destroy"
    if [[ -n "$MEMORY_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --memory $MEMORY_OVERRIDE"
    fi
    if [[ -n "$VCPU_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --vcpu $VCPU_OVERRIDE"
    fi
    if [[ -n "$DISK_OVERRIDE" ]]; then
      echo "  agent-vm -b $BRANCH_NAME --disk $DISK_OVERRIDE"
    fi
    echo ""
  fi
}

function cleanup_stopped_vms {
  echo "Cleaning up stopped VMs..."
  local cleaned_count=0

  # List all workspaces except default
  terraform workspace list 2>/dev/null | grep -v default | sed 's/^[* ] *//' | \
    while read -r ws; do
      terraform workspace select "$ws" >/dev/null 2>&1

      local vm_name="$ws"

      # Check if VM exists and is stopped
      if vm_domain_exists "$vm_name" && ! vm_is_running "$vm_name"; then
        echo "Destroying stopped VM: $vm_name"
        virsh destroy "$vm_name" 2>/dev/null || true
        virsh undefine "$vm_name" 2>/dev/null || true

        # Destroy Terraform resources
        terraform destroy -auto-approve >/dev/null 2>&1

        # Switch back and delete workspace
        terraform workspace select default >/dev/null 2>&1
        terraform workspace delete "$ws" 2>/dev/null

        cleaned_count=$((cleaned_count + 1))
      fi
    done

  # Return to default workspace
  terraform workspace select default >/dev/null 2>&1

  echo "Cleaned up $cleaned_count stopped VMs."
}

function list_vms {
  echo "Listing all VMs managed by agent-vm..."
  echo ""
  printf "%-30s %-15s %-15s\n" "VM NAME" "STATUS" "IP ADDRESS"
  printf "%-30s %-15s %-15s\n" "-------" "------" "----------"

  # List all workspaces except default
  terraform workspace list 2>/dev/null | grep -v default | sed 's/^[* ] *//' | \
    while read -r ws; do
      terraform workspace select "$ws" >/dev/null 2>&1

      local vm_name="$ws"
      local vm_ip
      vm_ip=$(terraform output -raw vm_ip 2>/dev/null || echo "N/A")

      local status="unknown"
      if vm_domain_exists "$vm_name"; then
        if vm_is_running "$vm_name"; then
          status="running"
        else
          status="stopped"
        fi
      else
        status="missing"
      fi

      printf "%-30s %-15s %-15s\n" "$vm_name" "$status" "$vm_ip"
    done

  # Return to default workspace
  terraform workspace select default >/dev/null 2>&1
  echo ""
}

function usage {
    cat - <<EOF
agent-vm: Unified VM workflow for AI coding agents

Usage: $0 [options] [-b <branch_name>] [-- command...]

Options:
  -b, --branch <name>         Branch name for git worktree
  --memory <MB>               VM memory in MB (default: 4096, creation only)
  --vcpu <count>              Virtual CPUs (default: 4, creation only)
  --disk <size>               Disk size like 60G (default: 40G, creation only)
  --list                      List all VMs and their status
  --stop                      Stop VM (requires -b)
  --destroy                   Destroy VM and workspace (requires -b)
  --cleanup                   Destroy all stopped VMs
  -h, --help                  Show this help

Arguments:
  command...                  Optional command to execute in VM
                              (connection closes after execution)

Examples:
  $0 -b feature-auth                    # Create/connect to VM
  $0 -b feature-auth -- claude          # Run claude directly
  $0 -b big-build --memory 16384        # Create VM with 16GB RAM
  $0 --list                             # List all VMs
  $0 -b feature-auth --destroy          # Destroy VM

Storage:
  * Worktrees: $WORKTREE_BASE_DIR
  * Terraform state: vm/.terraform/
  * SSH keys: vm/.ssh/vm-ssh-key-<vm-name>

Multi-VM:
  * Each branch gets its own VM via Terraform workspaces
  * Run same command again to reconnect (opens 2nd terminal)
  * VMs persist after exit (not destroyed like containers)
EOF
}

# Parse command line options
BRANCH_NAME=""
VM_COMMAND=()
USE_GIT=0
MEMORY_OVERRIDE=""
VCPU_OVERRIDE=""
DISK_OVERRIDE=""
ACTION=""  # list, stop, destroy, cleanup, or "" for connect

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--branch)
            BRANCH_NAME="$2"
            shift 2
            ;;
        --memory)
            MEMORY_OVERRIDE="$2"
            shift 2
            ;;
        --vcpu)
            VCPU_OVERRIDE="$2"
            shift 2
            ;;
        --disk)
            DISK_OVERRIDE="$2"
            shift 2
            ;;
        --list)
            ACTION="list"
            shift
            ;;
        --stop)
            ACTION="stop"
            shift
            ;;
        --destroy)
            ACTION="destroy"
            shift
            ;;
        --cleanup)
            ACTION="cleanup"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            VM_COMMAND=("$@")
            break
            ;;
        *)
            echo "Error: Unknown option: $1" >&2
            usage
            exit 1
            ;;
    esac
done

# Source common functions
# shellcheck source=vm-common.sh
# shellcheck disable=SC1091
source "$SCRIPT_DIR/vm-common.sh"

cd "$SCRIPT_DIR" || exit 1

# Handle list action
if [[ "$ACTION" == "list" ]]; then
  list_vms
  exit 0
fi

# Handle cleanup action
if [[ "$ACTION" == "cleanup" ]]; then
  cleanup_stopped_vms
  exit 0
fi

# Stop and destroy require branch name
if [[ "$ACTION" == "stop" || "$ACTION" == "destroy" ]] && [[ -z "$BRANCH_NAME" ]]; then
  echo "Error: --stop and --destroy require -b <branch_name>" >&2
  exit 1
fi

# Handle stop/destroy actions
if [[ "$ACTION" == "stop" || "$ACTION" == "destroy" ]]; then
  # Determine VM naming (needed for stop/destroy)
  if [[ ! -d .git ]]; then
    echo "Error: Must be in a git repository to use -b option" >&2
    exit 1
  fi

  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  VM_NAME="${REPO_NAME}-${BRANCH_NAME}"

  if [[ "$ACTION" == "stop" ]]; then
    stop_vm "$VM_NAME"
    exit 0
  fi

  if [[ "$ACTION" == "destroy" ]]; then
    destroy_vm "$VM_NAME" "$VM_NAME"
    exit 0
  fi
fi

# Determine if we should use git worktrees
if [[ -n "$BRANCH_NAME" ]]; then
  if [[ ! -d .git ]]; then
    echo "Error: Must be in a git repository to use -b option" >&2
    exit 1
  fi

  USE_GIT=1
  REPO_NAME="$(basename "$(git rev-parse --show-toplevel)")"
  WORKTREE_DIR="$WORKTREE_BASE_DIR/${REPO_NAME}-${BRANCH_NAME}"
  VM_NAME="${REPO_NAME}-${BRANCH_NAME}"

  # Create worktree base directory if needed
  mkdir -p "$WORKTREE_BASE_DIR"

  # Setup worktree
  setup_worktree "$WORKTREE_DIR" "$BRANCH_NAME"

  # Get main repo directory for git operations
  MAIN_REPO_DIR="$(git rev-parse --show-toplevel)"
else
  echo "Error: -b <branch> is required" >&2
  exit 1
fi

# Detect network subnet (same logic as vm-up.sh)
if [ -z "$NETWORK_SUBNET" ]; then
  # Get the current VM's IP address (if any) on 192.168.x.x
  CURRENT_IP=$(ip -4 addr show | grep -oP '(?<=inet\s)192\.168\.\d+\.\d+(?=/)' | head -1)

  if [ -n "$CURRENT_IP" ]; then
    # Extract third octet from current IP
    CURRENT_THIRD_OCTET=$(echo "$CURRENT_IP" | cut -d. -f3)

    # Use different subnet: if we're on 122 or 123, use 200
    # Otherwise use current + 1 (wrapping at 255)
    if [ "$CURRENT_THIRD_OCTET" -eq 122 ] || [ "$CURRENT_THIRD_OCTET" -eq 123 ]; then
      NETWORK_SUBNET=200
      echo "Detected outer VM network: 192.168.$CURRENT_THIRD_OCTET.0/24"
      echo "Using subnet 192.168.$NETWORK_SUBNET.0/24 for nested VM"
    else
      NETWORK_SUBNET=$(( (CURRENT_THIRD_OCTET + 1) % 256 ))
      echo "Detected outer VM network: 192.168.$CURRENT_THIRD_OCTET.0/24"
      echo "Using subnet 192.168.$NETWORK_SUBNET.0/24 for nested VM"
    fi
  else
    # Not inside a VM on 192.168.x.x, use default
    NETWORK_SUBNET=123
  fi
fi

# Check if workspace exists
if workspace_exists "$VM_NAME"; then
  echo "VM workspace exists: $VM_NAME"

  # Select workspace
  terraform workspace select "$VM_NAME"

  # Check if VM domain exists
  if vm_domain_exists "$VM_NAME"; then
    if vm_is_running "$VM_NAME"; then
      echo "VM is already running: $VM_NAME"
      warn_resource_overrides_ignored
    else
      echo "VM exists but is stopped. Starting..."
      warn_resource_overrides_ignored
      virsh start "$VM_NAME"
      echo "VM started: $VM_NAME"
    fi
  else
    echo "Warning: Workspace exists but VM domain missing. Recreating..."
    # Workspace exists but VM doesn't - clean up and recreate
    terraform workspace select default
    terraform workspace delete "$VM_NAME"

    # Fall through to creation below
    CREATE_NEW_VM=1
  fi
else
  CREATE_NEW_VM=1
fi

# Create new VM if needed
if [[ "${CREATE_NEW_VM:-0}" == "1" ]]; then
  echo "Creating new VM: $VM_NAME"

  # Create workspace
  terraform workspace new "$VM_NAME"

  # Find available IP
  VM_IP=$(find_available_ip "$SCRIPT_DIR" "$NETWORK_SUBNET")
  echo "Allocated IP: $VM_IP"

  # Build terraform variables
  TERRAFORM_VARS=(
    -var="vm_name=$VM_NAME"
    -var="vm_hostname=$VM_NAME"
    -var="worktree_path=$WORKTREE_DIR"
    -var="main_repo_path=$MAIN_REPO_DIR"
    -var="vm_ip=$VM_IP"
    -var="network_subnet_third_octet=$NETWORK_SUBNET"
    -var="user_uid=$(id -u)"
    -var="user_gid=$(id -g)"
  )

  # Add resource overrides if provided
  if [[ -n "$MEMORY_OVERRIDE" ]]; then
    TERRAFORM_VARS+=(-var="vm_memory=$MEMORY_OVERRIDE")
  fi
  if [[ -n "$VCPU_OVERRIDE" ]]; then
    TERRAFORM_VARS+=(-var="vm_vcpu=$VCPU_OVERRIDE")
  fi
  if [[ -n "$DISK_OVERRIDE" ]]; then
    # Convert disk size to bytes (e.g., 60G -> 64424509440)
    DISK_BYTES=$(numfmt --from=iec "${DISK_OVERRIDE}")
    TERRAFORM_VARS+=(-var="vm_disk_size=$DISK_BYTES")
  fi

  # Add GCP credentials if available
  GCP_CREDS_DEFAULT="$HOME/.config/gcloud/application_default_credentials.json"
  if [[ -n "$GOOGLE_APPLICATION_CREDENTIALS" ]]; then
    GCP_CREDS_PATH="$GOOGLE_APPLICATION_CREDENTIALS"
  else
    GCP_CREDS_PATH="$GCP_CREDS_DEFAULT"
  fi

  if [[ -f "$GCP_CREDS_PATH" ]]; then
    echo "Injecting GCP credentials from: $GCP_CREDS_PATH"
    TERRAFORM_VARS+=(-var="gcp_service_account_key_path=$GCP_CREDS_PATH")

    if [[ -n "$ANTHROPIC_VERTEX_PROJECT_ID" ]]; then
      TERRAFORM_VARS+=(-var="vertex_project_id=$ANTHROPIC_VERTEX_PROJECT_ID")
    fi

    if [[ -n "$CLOUD_ML_REGION" ]]; then
      TERRAFORM_VARS+=(-var="vertex_region=$CLOUD_ML_REGION")
    fi
  fi

  # Initialize terraform if needed
  if [[ ! -d ".terraform" ]] || [[ ! -f ".terraform.lock.hcl" ]]; then
    echo "Initializing Terraform..."
    terraform init
  fi

  # Apply terraform
  echo "Provisioning VM with Terraform..."
  terraform apply -auto-approve "${TERRAFORM_VARS[@]}"

  # Remove old SSH key from known_hosts
  ssh-keygen -R "$VM_IP" 2>/dev/null || true

  echo "VM created successfully: $VM_NAME"
fi
